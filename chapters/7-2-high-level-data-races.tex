\subsection{High-Level Data Races}

Also known as high-level atomicity violations.
This happens when seemingly atomic code has interleavings that lead to a data race.

\begin{lstlisting}[caption={Class \texttt{Pair} definition, notice the synchronized methods.}]
class Pair {
  synchronized int getX() {
    return pair.x:
  }

  synchronized int getY() {
    return pair.y:
  }

  synchronized void setPair(
    int x,
    int y
  ) {
    this.x = x;
    this.y = y;
  }

  boolean areEqual() {
    int x = this.getX(); // synchronized
    int y = this.getY(); // synchronized
    return x == y;
  }
}
\end{lstlisting}

Seemingly the methods are well synchronized,
however if a thread calls \texttt{areEqual},
it is possible for the pair class to be changed between \texttt{get} calls,
running an interleaving like the following.

\begin{lstlisting}[caption={Possible incorrect interleaving. Assuming \texttt{y != y'}.}]
getX();
setPair(x', y');
getY(); // y is now y'
\end{lstlisting}

\subsubsection{Stale-Value Errors}

Stale-Value errors are caused by the privatization of data.

\begin{lstlisting}[caption={Stale-Value error example.}]
void setYToXTimesTwo() {
  int x = getX();
  setY(2 * x); // x may have changed
}

@Atomic
synchronized int getX() {
  return x;
}

@Atomic
synchronized int setY(int y) {
  this.y = y;
}
\end{lstlisting}

\subsubsection{Detecting High-Level Data Races}

A view of an atomic block $B$, named $V(B)$, is the set of variables accessed inside the atomic code block $B$.
We can define a \textit{read view} of $B$ as $V_{R}(B)$ as the set of variables read inside the atomic code block $B$.
Analogously the \textit{write view} of $B$, $V_{W}(B)$ is the set of variables written inside the atomic code block $B$.

\begin{lstlisting}[caption={
  The \texttt{getX} has the read view $V_{R}(\mathtt{getX}) = \{\mathtt{x}\}$ and the write view $V_{W}(\mathtt{getX}) = \{\}$.
}]
public int getX() {
  return this.x;
}
\end{lstlisting}

\paragraph{Direct Correlation}
There is a direct correlation between a read variable $x$ and a written variable $y$ if in the dependency graph $D$ there is a path from $x$ to $y$.

\paragraph{Common Correlation}
There is a common correlation between read variables $x$ and $y$ if,
in a dependency graph $D$, there is a written variable $z$ such that:
\begin{equation*}
  z \neq x, z \neq y : \exists \left(x \rightarrow z, y \rightarrow z\right)
\end{equation*}

\paragraph{High-Level Data Race Detection}
To detect high-level data races we first define \textit{thread views}.
A view is the set of variables guarded by a given lock.
Let $\mathit{F}$ be the set of fields of a program run,
view $v \in \mathbb{P}(\mathit{F})$ is a subset of $\mathit{F}$.
The set of generated views $V(t) \subseteq \mathbb{P}(\mathit{F})$ of a thread $t$ is the set of all views $v$ generated by $t$.

A view $v_m$ generated by a thread is a maximal view, if and only if it is maximal with respect to set inclusion in $V(t)$:
\begin{equation*}
  \forall v \in V(t)[v_m \subseteq v \rightarrow v_m = v]
\end{equation*}

Let $M(t)$ be the set of all maximal views of thread $t$.
Only two views which have fields in common can be responsible for a conflict.

Given a set of views $V(t)$ generated by $t$ and a view $v'$ generated by another thread,
the overlapping views of $t$ with $v'$ are all non-empty intersections of views in $V(t)$ with $v'$:
\begin{equation*}
  \mathnormal{overlap}(t, v') \equiv \{v' \cap v | (v \in V(t)) \wedge (v \cap v' \neq \emptyset)\}
\end{equation*}

A set of views $V(t)$ is compatible with the maximal view $v_m$ of another thread if and only if all overlapping views of $t$ with $v_m$ form a chain:
\begin{equation*}
  \mathnormal{compatible}(t, v_m)~\mathit{iff}~\forall v_1, v_2 \in \mathnormal{overlap}(t, v_m)[v_1 \subseteq v_2 \vee v_2 \subseteq v_1]
\end{equation*}

View consistency is defined as mutual compatibility between all threads:
A thread is only allowed to use views that are compatible with the maximal views of all other threads.
\begin{equation*}
  \forall t_1 \neq t_2, v_m \in M(t)[\mathnormal{compatible}(t_2, v_m)]
\end{equation*}

Example of an high-level data race detection:

\begin{equation}
  \begin{split}
    V_{max}(T_1) & = \{x, y\} \\
    V_{max}(T_2) & = \{x\}, \{y\} \\
    V_A & = V_{max}(T_1) \cap \{x\} \\
    V_B & = V_{max}(T_1) \cap \{y\} \\
    V_A \nsubseteq V_B & \wedge V_B \nsubseteq V_A
  \end{split}
\end{equation}
